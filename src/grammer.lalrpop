use std::str::FromStr;
use std::collections::VecDeque;
use crate::ast;
use crate::ast::Clause;

grammar;

MultiTerm: Vec<Box<ast::Term>> = {
    <t:Term> => vec![Box::new(t)],
    <mut v:MultiTerm> "," <t:Term> => { v.push(Box::new(t)); v }
}

SingleClause: Clause = <p:Atom> "(" <args:MultiTerm> ")" => Clause{ prop_name : p, args : args };

pub MultiClauses: VecDeque<ast::Clause> = {
    <c:SingleClause> => VecDeque::from(vec![c]),
    <mut v:MultiClauses> "," <c:SingleClause> => { v.push_back(c); v }
}

pub Term: ast::Term = {
    <a:Atom> => ast::Term::Atom(a),
    <v:Var> => ast::Term::Variable(v),
    <c:SingleClause> => ast::Term::Compound(c),
    "(" <t:Term> ")" => t
};

pub Rule: ast::Rule = {
    <c:SingleClause> => ast::Rule{ conclusion : c, conds : VecDeque::new() },
    <c:SingleClause> ":-" <conds:MultiClauses> => ast::Rule{ conclusion : c, conds : conds }
}

Atom: String = <s:r"[a-z]\w*"> => s.to_string();
Var: String = <s:r"_|([A-Z]\w*)"> => s.to_string();
Num: i32 = <s:r"[0-9]+"> => i32::from_str(s).unwrap();